<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Oscilloscope pédagogique</title>
    <style>
        :root {
            /* Zone écran (en %) repérée sur l'image fournie */
            --screen-left: 10.91%;
            --screen-top: 17.7%;
            --screen-width: 55.45%;
            --screen-height: 65.7%;
            /* Centres visuels des boutons (tes mesures) */
            --knob-v-left: 85.9%;
            --knob-v-top: 33.9%;
            --knob-t-left: 85.9%;
            --knob-t-top: 74.4%;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: #0e0f12;
            color: #111;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        }

        .wrap {
            display: grid;
            place-items: center;
            min-height: 100%;
            padding: 12px;
        }

        /* Toujours ENTIER dans l’écran (image ~1116×768 ⇒ ratio ≈ 1.454) */
        .scope {
            position: relative;
            width: min(96vw, calc(96vh * 1.454));
            max-width: 1400px;
            filter: drop-shadow(0 12px 24px rgba(0, 0, 0, .35));
        }

        .scope img {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 10px;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* Canvas exactement à la taille de l'écran quadrillé → rien ne déborde */
        #trace {
            position: absolute;
            left: var(--screen-left);
            top: var(--screen-top);
            width: var(--screen-width);
            height: var(--screen-height);
            pointer-events: none;
        }

        .panel {
            position: absolute;
            left: clamp(10px, 2vw, 24px);
            top: clamp(8px, 2vw, 20px);
            background: rgba(255, 255, 255, .96);
            border: 1px solid #e2e5ec;
            border-radius: 14px;
            padding: 12px 14px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px 10px;
            z-index: 10;
            backdrop-filter: blur(4px);
        }

        .panel h2 {
            grid-column: 1/-1;
            margin: 0 0 6px;
            font-size: 14px;
            letter-spacing: .02em;
            color: #333;
        }

        .panel label {
            font-size: 12px;
            color: #333;
        }

        .panel input,
        .panel select {
            width: 150px;
        }

        .panel .full {
            grid-column: 1/-1;
        }

        /* --- KNOBS (boutons rotatifs) --- */
        .knob {
            position: absolute;
            transform: translate(-50%, -50%);
            width: clamp(90px, 12vw, 150px);
            height: clamp(90px, 12vw, 150px);
            border-radius: 50%;
            cursor: grab;
            z-index: 8;
        }

        .knob:active {
            cursor: grabbing;
        }

        .knob .needle {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -100%) rotate(0deg);
            width: 4px;
            height: 45%;
            background: #111;
            border-radius: 4px;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, .8), 0 1px 4px rgba(0, 0, 0, .3);
            transform-origin: 50% 100%;
        }

        .knob .cap {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 18%;
            height: 18%;
            border-radius: 50%;
            background: #e9e7df;
            border: 1px solid rgba(0, 0, 0, .25);
            box-shadow: inset 0 2px 3px rgba(0, 0, 0, .2);
        }

        .knob .value {
            position: absolute;
            left: 50%;
            top: -10px;
            transform: translate(-50%, -100%);
            font-size: 12px;
            background: #fff;
            border: 1px solid #c9ccd3;
            border-radius: 10px;
            padding: 4px 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, .12);
            white-space: nowrap;
            user-select: none;
        }

        #knobV {
            left: var(--knob-v-left);
            top: var(--knob-v-top);
        }

        #knobT {
            left: var(--knob-t-left);
            top: var(--knob-t-top);
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="scope" id="scope">
            <img id="bg" src="Oscilloscope.png" alt="Oscilloscope pédagogique" />
            <!-- Canvas strictement à la zone de l’écran -->
            <canvas id="trace" width="800" height="600" aria-hidden="true"></canvas>

            <!-- KNOBS (rotatifs) -->
            <div class="knob" id="knobV" aria-label="V/div">
                <div class="value" id="vdivVal">1 V/div</div>
                <div class="needle" id="vNeedle"></div>
                <div class="cap"></div>
            </div>
            <div class="knob" id="knobT" aria-label="sec/div">
                <div class="value" id="tdivVal">2 ms/div</div>
                <div class="needle" id="tNeedle"></div>
                <div class="cap"></div>
            </div>

            <!-- Paramètres d'entrée -->
            <form class="panel" id="controls">
                <h2>Paramètres du signal</h2>
                <label>Forme
                    <select id="wave">
                        <option value="sine">Sinusoïdal</option>
                        <option value="square">Carré</option>
                        <option value="triangle">Triangle</option>
                    </select>
                </label>
                <label>Fréquence (Hz)
                    <input id="freq" type="number" min="0.01" step="0.01" value="50" />
                </label>
                <label>Amplitude crête (V)
                    <input id="amp" type="number" min="0" step="0.01" value="2" />
                </label>
                <label>Décalage DC (V)
                    <input id="offset" type="number" step="0.01" value="0" />
                </label>
                <label>Périodes à afficher
                    <input id="cycles" type="number" min="0.25" step="0.25" value="2" />
                </label>
                <div class="full"><button type="button" id="reset">Réinitialiser centrage</button></div>
            </form>
        </div>
    </div>

    <script>
        // --- constantes ---
        const DIV_X = 10, DIV_Y = 8;
        const CENTER_TWEAK_PX = -2; // remonte subtilement la trace pour coïncider au centre visuel

        // Calibres (ordre horaire)
        const VDIV_STEPS = [5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001];
        const TDIV_STEPS = [0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005, 0.0002, 0.0001];

        // Indices de départ (1 V/div ; 2 ms/div)
        let vIndex = VDIV_STEPS.indexOf(1);
        let tIndex = TDIV_STEPS.indexOf(0.002);

        const cvs = document.getElementById('trace');
        const ctx = cvs.getContext('2d');

        // UI signal
        const ui = {
            wave: document.getElementById('wave'),
            freq: document.getElementById('freq'),
            amp: document.getElementById('amp'),
            offset: document.getElementById('offset'),
            cycles: document.getElementById('cycles'),
            reset: document.getElementById('reset')
        };

        // Position verticale (0 au centre)
        let yCenterDiv = DIV_Y / 2;
        ui.reset.addEventListener('click', () => { yCenterDiv = DIV_Y / 2; draw(); });

        function resizeCanvasToCSS() {
            const rect = cvs.getBoundingClientRect();
            if (rect.width < 2 || rect.height < 2) return false; // layout pas prêt
            const dpr = window.devicePixelRatio || 1;
            cvs.width = Math.round(rect.width * dpr);
            cvs.height = Math.round(rect.height * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // dessiner en unités CSS
            return true;
        }

        function generateSamples(vPerDiv, sPerDiv) {
            const w = Math.max(2, cvs.getBoundingClientRect().width);

            const secTotal = sPerDiv * DIV_X;          // 10 divisions
            const f = Math.max(0.000001, parseFloat(ui.freq.value));
            const A = Math.abs(parseFloat(ui.amp.value));
            const DC = parseFloat(ui.offset.value);

            const stepT = secTotal / (w - 1);
            const pts = [];
            for (let x = 0; x < w; x++) {
                const t = (x * stepT) - (secTotal / 2); // centré
                let y = 0;
                const ph = 2 * Math.PI * f * t;
                switch (ui.wave.value) {
                    case 'sine': y = A * Math.sin(ph); break;
                    case 'square': y = (Math.sin(ph) >= 0 ? A : -A); break;
                    case 'triangle': {
                        const T = 1 / f;
                        const frac = (t / T) - Math.floor(t / T + 0.5);
                        y = A * (2 * Math.abs(2 * frac) - 1);
                        break;
                    }
                }
                y += DC;
                pts.push({ x, y });
            }
            return { pts, vPerDiv, DC };
        }

        function draw() {
            if (!resizeCanvasToCSS()) return;

            const rect = cvs.getBoundingClientRect();
            const W = rect.width, H = rect.height;

            const vPerDiv = VDIV_STEPS[vIndex];
            const sPerDiv = TDIV_STEPS[tIndex];

            const { pts, DC } = generateSamples(vPerDiv, sPerDiv);

            // Échelles
            const pxPerDivY = H / DIV_Y;
            const centerY = yCenterDiv * pxPerDivY + CENTER_TWEAK_PX;
            const pxPerVolt = pxPerDivY / vPerDiv;

            // Nettoyage
            ctx.clearRect(0, 0, W, H);

            // Ligne DC (rouge)
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#d11';
            ctx.beginPath();
            const yDC = centerY - DC * pxPerVolt;
            ctx.moveTo(0, yDC); ctx.lineTo(W, yDC);
            ctx.stroke();

            // Trace verte (épaisseur raisonnable)
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#0a7d2c';
            ctx.beginPath();
            for (let i = 0; i < pts.length; i++) {
                const p = pts[i];
                const x = p.x;
                const y = centerY - p.y * pxPerVolt;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // -------- KNOB DRAG (0° en haut, 0→330°) --------
        const MIN_ANGLE = 0, MAX_ANGLE = 330;

        function stepAngle(list, idx) {
            return MIN_ANGLE + (MAX_ANGLE - MIN_ANGLE) * (idx / (list.length - 1));
        }
        function setNeedle(needle, list, idx) {
            const deg = stepAngle(list, idx);
            needle.style.transform = `translate(-50%,-100%) rotate(${deg}deg)`; // 0° = haut
        }

        // Angle polaire en degrés, 0° en HAUT, sens HORAIRE, 0..360
        function polarAngleCWdeg(x, y) {
            let a = Math.atan2(y, x) * 180 / Math.PI;  // [-180,180]
            a = (a + 450) % 360;                     // 0..360, 0° en haut, CW
            return a;
        }
        function angleFromEvent(e, el) {
            const r = el.getBoundingClientRect();
            const cx = r.left + r.width / 2;
            const cy = r.top + r.height / 2;
            const ex = (e.touches ? e.touches[0].clientX : e.clientX) - cx;
            const ey = (e.touches ? e.touches[0].clientY : e.clientY) - cy;
            let ang = polarAngleCWdeg(ex, ey);              // 0..360
            ang = Math.max(MIN_ANGLE, Math.min(MAX_ANGLE, ang)); // clamp 0..330
            return ang;
        }
        function idxFromAngle(ang, list) {
            const ratio = (ang - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE); // 0..1
            return Math.max(0, Math.min(list.length - 1, Math.round(ratio * (list.length - 1))));
        }

        const vNeedle = document.getElementById('vNeedle');
        const tNeedle = document.getElementById('tNeedle');
        const vLabel = document.getElementById('vdivVal');
        const tLabel = document.getElementById('tdivVal');

        const fmtV = v => (v >= 1 ? `${v} V/div` : (v >= 0.001 ? `${v} V/div` : `${v * 1000} mV/div`));
        function fmtT(s) {
            if (s >= 1) return `${s} s/div`;
            if (s >= 0.001) return `${s * 1000} ms/div`;
            return `${s * 1e6} µs/div`;
        }

        function attachKnobDrag(el, list, getIdx, setIdx, labelEl, fmt, needleEl) {
            let dragging = false;

            function applyIndex(i) {
                const idx = Math.max(0, Math.min(list.length - 1, i));
                if (idx !== getIdx()) {
                    setIdx(idx);
                    labelEl.textContent = fmt(list[idx]);
                    setNeedle(needleEl, list, idx);
                    draw();
                }
            }
            function onDown(e) {
                dragging = true; e.preventDefault(); onMove(e);
            }
            function onMove(e) {
                if (!dragging) return;
                e.preventDefault();
                const ang = angleFromEvent(e, el);       // 0..330
                const idx = idxFromAngle(ang, list);     // snap au cran le + proche
                applyIndex(idx);
            }
            function onUp() { dragging = false; }

            // Souris
            el.addEventListener('mousedown', onDown);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
            // Tactile
            el.addEventListener('touchstart', onDown, { passive: false });
            window.addEventListener('touchmove', onMove, { passive: false });
            window.addEventListener('touchend', onUp);

            // init visuelle
            labelEl.textContent = fmt(list[getIdx()]);
            setNeedle(needleEl, list, getIdx());
        }

        attachKnobDrag(
            document.getElementById('knobV'), VDIV_STEPS,
            () => vIndex, (i) => { vIndex = i; },
            vLabel, fmtV, vNeedle
        );
        attachKnobDrag(
            document.getElementById('knobT'), TDIV_STEPS,
            () => tIndex, (i) => { tIndex = i; },
            tLabel, fmtT, tNeedle
        );

        // ---- INIT robuste : attendre l'image + redraw sur resize ----
        const bg = document.getElementById('bg');
        const ro = new ResizeObserver(() => draw());
        function init() {
            ro.observe(document.getElementById('scope'));
            ro.observe(cvs);
            requestAnimationFrame(() => { draw(); setTimeout(draw, 80); });
        }
        if (bg.complete) init(); else bg.addEventListener('load', init, { once: true });

        // Redessiner si fenêtre redimensionnée + si paramètres changent
        window.addEventListener('resize', draw);
        ['change', 'input'].forEach(ev => {
            Object.values(ui).forEach(el => el && el.addEventListener(ev, draw));
        });
    </script>
</body>

</html>