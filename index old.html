<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Oscilloscope pédagogique</title>
<style>
  :root{
    /* Zone écran (en %) repérée sur l'image */
    --screen-left: 10.91%;
    --screen-top: 17.7%;
    --screen-width: 55.45%;
    --screen-height: 65.7%;
    /* Centres visuels des boutons (tes mesures) */
    --knob-v-left: 85.9%;
    --knob-v-top: 33.9%;
    --knob-t-left: 85.9%;
    --knob-t-top: 74.4%;
  }

  html, body{
    height:100%; margin:0; background:#0e0f12; color:#111;
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  }

  /* Layout global : panneau à gauche, oscillo à droite */
  .app{
    display:grid;
    grid-template-columns: minmax(220px, 260px) 1fr;
    gap: 16px;
    min-height:100vh;
    align-items:start;
    padding:12px;
  }

  /* Colonne de droite (oscillo) */
  .wrap{ display:grid; place-items:center; min-height:100%; }

  /* Toujours ENTIER dans l’écran (image ~1116×768 ⇒ ratio ≈ 1.454) */
  .scope{
    position:relative;
    width: min(96vw, calc(96vh * 1.454));
    max-width: 1400px;
    filter: drop-shadow(0 12px 24px rgba(0,0,0,.35));
  }
  .scope img{ width:100%; height:auto; display:block; border-radius:10px; user-select:none; -webkit-user-drag:none; }

  /* Canvas exactement à la taille de l'écran quadrillé */
  #trace{
    position:absolute;
    left:var(--screen-left);  top:var(--screen-top);
    width:var(--screen-width); height:var(--screen-height);
    pointer-events:none;
  }

  /* Panneau latéral fin */
  .sidebar{ position:sticky; top:12px; align-self:start; }
  .sidepanel{
    display:grid; gap:10px;
    background:rgba(255,255,255,.96);
    border:1px solid #e2e5ec; border-radius:14px;
    padding:12px 14px; width:100%;
    backdrop-filter: blur(4px);
  }
  .sidepanel h2{ margin:0 0 6px; font-size:14px; letter-spacing:.02em; color:#333; }
  .sidepanel label{ display:grid; gap:6px; font-size:12px; color:#333; }
  .sidepanel input, .sidepanel select{
    width:100%; padding:6px 8px; font-size:14px;
    border:1px solid #c9ccd3; border-radius:8px; background:#fff;
  }
  .sidepanel button{
    margin-top:6px; padding:8px 10px; font-size:14px;
    border:1px solid #c9ccd3; border-radius:10px; background:#fff; cursor:pointer;
    box-shadow:0 1px 3px rgba(0,0,0,.08);
  }
  .sidepanel button:hover{ background:#f6f7fb; }

  /* --- KNOBS (boutons rotatifs) --- */
  .knob{
    position:absolute; transform:translate(-50%,-50%);
    width: clamp(90px, 12vw, 150px); height: clamp(90px, 12vw, 150px);
    border-radius: 50%;
    cursor: grab; z-index: 8;
  }
  .knob:active{ cursor: grabbing; }
  .knob .needle{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-100%) rotate(0deg);
    width:4px; height:45%;
    background:#111; border-radius:4px;
    box-shadow: 0 0 0 2px rgba(255,255,255,.8), 0 1px 4px rgba(0,0,0,.3);
    transform-origin: 50% 100%;
  }
  .knob .cap{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    width:18%; height:18%; border-radius:50%;
    background: #e9e7df; border:1px solid rgba(0,0,0,.25);
    box-shadow: inset 0 2px 3px rgba(0,0,0,.2);
  }
  .knob .value{
    position:absolute; left:50%; top:-10px; transform:translate(-50%,-100%);
    font-size:12px; background:#fff; border:1px solid #c9ccd3; border-radius:10px;
    padding:4px 8px; box-shadow:0 2px 6px rgba(0,0,0,.12);
    white-space:nowrap; user-select:none;
  }

  #knobV{ left:var(--knob-v-left); top:var(--knob-v-top); }
  #knobT{ left:var(--knob-t-left); top:var(--knob-t-top); }
</style>
</head>
<body>
<div class="app">
  <!-- PANNEAU LATERAL -->
  <aside class="sidebar">
    <form class="sidepanel" id="controls">
      <h2>Entrée</h2>
      <label>Forme
        <select id="wave">
          <option value="sine">Sinusoïdal</option>
          <option value="square">Carré</option>
          <option value="triangle">Triangle</option>
        </select>
      </label>
      <label>Amplitude crête (V)
        <input id="amp" type="number" min="0" step="0.01" value="2" />
      </label>
      <label>Décalage DC (V)
        <input id="offset" type="number" step="0.01" value="0" />
      </label>
      <label>Fréquence (Hz)
        <input id="freq" type="number" min="0.000001" step="0.01" value="50" />
      </label>
      <label>Période (s)
        <input id="per" type="number" min="0.000001" step="0.000001" value="" placeholder="auto" />
      </label>
      <button type="button" id="exportPng">Exporter PNG (écran)</button>
    </form>
  </aside>

  <!-- OSCILLOSCOPE -->
  <div class="wrap">
    <div class="scope" id="scope">
      <img id="bg" src="Oscilloscope.png" alt="Oscilloscope pédagogique" />
      <!-- Canvas strictement à la zone de l’écran -->
      <canvas id="trace" width="800" height="600" aria-hidden="true"></canvas>

      <!-- KNOBS (rotatifs) -->
      <div class="knob" id="knobV" aria-label="V/div">
        <div class="value" id="vdivVal">1 V/div</div>
        <div class="needle" id="vNeedle"></div>
        <div class="cap"></div>
      </div>
      <div class="knob" id="knobT" aria-label="sec/div">
        <div class="value" id="tdivVal">2 ms/div</div>
        <div class="needle" id="tNeedle"></div>
        <div class="cap"></div>
      </div>
    </div>
  </div>
</div>

<script>
  // --- constantes ---
  const DIV_X = 10, DIV_Y = 8;
  const CENTER_TWEAK_PX = -2; // remonte subtilement la trace pour coïncider au centre visuel

  // Calibres (ordre horaire)
  const VDIV_STEPS = [5,2,1,0.5,0.2,0.1,0.05,0.02,0.01,0.005,0.002,0.001];
  const TDIV_STEPS = [0.5,0.2,0.1,0.05,0.02,0.01,0.005,0.002,0.001,0.0005,0.0002,0.0001];

  // Indices de départ (1 V/div ; 2 ms/div)
  let vIndex = VDIV_STEPS.indexOf(1);
  let tIndex = TDIV_STEPS.indexOf(0.002);

  const cvs = document.getElementById('trace');
  const ctx = cvs.getContext('2d');

  // UI
  const ui = {
    wave: document.getElementById('wave'),
    freq: document.getElementById('freq'),
    per:  document.getElementById('per'),
    amp:  document.getElementById('amp'),
    offset: document.getElementById('offset'),
    exportPng: document.getElementById('exportPng')
  };

  // Position verticale (0 au centre)
  let yCenterDiv = DIV_Y / 2;

  function resizeCanvasToCSS(){
    const rect = cvs.getBoundingClientRect();
    if (rect.width < 2 || rect.height < 2) return false; // layout pas prêt
    const dpr = window.devicePixelRatio || 1;
    cvs.width = Math.round(rect.width * dpr);
    cvs.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); // dessiner en unités CSS
    return true;
  }

  function generateSamples(vPerDiv, sPerDiv){
    const w = Math.max(2, cvs.getBoundingClientRect().width);

    const secTotal = sPerDiv * DIV_X;          // 10 divisions
    const f  = Math.max(0.000001, parseFloat(ui.freq.value));
    const A  = Math.abs(parseFloat(ui.amp.value));
    const DC = parseFloat(ui.offset.value);

    const stepT = secTotal / (w - 1);
    const pts = [];
    for (let x=0; x<w; x++){
      const t = (x * stepT) - (secTotal/2); // centré
      let y = 0;
      const ph = 2*Math.PI*f*t;
      switch (ui.wave.value){
        case 'sine':     y = A * Math.sin(ph); break;
        case 'square':   y = (Math.sin(ph) >= 0 ? A : -A); break;
        case 'triangle': {
          const T = 1/f;
          const frac = (t / T) - Math.floor(t / T + 0.5);
          y = A * (2 * Math.abs(2*frac) - 1);
          break;
        }
      }
      y += DC;
      pts.push({x, y});
    }
    return {pts, vPerDiv, DC};
  }

  function draw(){
    if (!resizeCanvasToCSS()) return;

    const rect = cvs.getBoundingClientRect();
    const W = rect.width, H = rect.height;

    const vPerDiv = VDIV_STEPS[vIndex];
    const sPerDiv = TDIV_STEPS[tIndex];

    const {pts, DC} = generateSamples(vPerDiv, sPerDiv);

    // Échelles
    const pxPerDivY = H / DIV_Y;
    const centerY   = yCenterDiv * pxPerDivY + CENTER_TWEAK_PX;
    const pxPerVolt = pxPerDivY / vPerDiv;

    // Nettoyage
    ctx.clearRect(0,0,W,H);

    // Ligne DC (rouge) si visible
    const EPS_V = 1e-6;
    if (Math.abs(DC) > EPS_V){
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#d11';
      ctx.beginPath();
      const yDC = centerY - DC * pxPerVolt;
      ctx.moveTo(0, yDC); ctx.lineTo(W, yDC);
      ctx.stroke();
    }

    // Trace verte
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#0a7d2c';
    ctx.beginPath();
    for (let i=0;i<pts.length;i++){
      const p = pts[i];
      const x = p.x;
      const y = centerY - p.y * pxPerVolt;
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // -------- KNOB DRAG (0° en haut, 0→330°) --------
  const MIN_ANGLE = 0, MAX_ANGLE = 330;

  function stepAngle(list, idx){
    return MIN_ANGLE + (MAX_ANGLE - MIN_ANGLE) * (idx / (list.length - 1));
  }
  function setNeedle(needle, list, idx){
    const deg = stepAngle(list, idx);
    needle.style.transform = `translate(-50%,-100%) rotate(${deg}deg)`; // 0° = haut
  }

  // Angle polaire en degrés, 0° en HAUT, sens HORAIRE, 0..360
  function polarAngleCWdeg(x, y){
    let a = Math.atan2(y, x) * 180/Math.PI;  // [-180,180]
    a = (a + 450) % 360;                     // 0..360, 0° en haut, CW
    return a;
  }
  function angleFromEvent(e, el){
    const r = el.getBoundingClientRect();
    const cx = r.left + r.width/2;
    const cy = r.top  + r.height/2;
    const ex = (e.touches ? e.touches[0].clientX : e.clientX) - cx;
    const ey = (e.touches ? e.touches[0].clientY : e.clientY) - cy;
    let ang = polarAngleCWdeg(ex, ey);              // 0..360
    ang = Math.max(MIN_ANGLE, Math.min(MAX_ANGLE, ang)); // clamp 0..330
    return ang;
  }
  function idxFromAngle(ang, list){
    const ratio = (ang - MIN_ANGLE) / (MAX_ANGLE - MIN_ANGLE); // 0..1
    return Math.max(0, Math.min(list.length - 1, Math.round(ratio * (list.length - 1))));
  }

  const vNeedle = document.getElementById('vNeedle');
  const tNeedle = document.getElementById('tNeedle');
  const vLabel  = document.getElementById('vdivVal');
  const tLabel  = document.getElementById('tdivVal');

  function fmtV(v){
    if (v >= 1) return `${v} V/div`;
    if (v >= 1e-3) return `${v*1e3} mV/div`;
    return `${v*1e6} µV/div`;
  }
  function fmtT(s){
    if (s >= 1) return `${s} s/div`;
    if (s >= 0.001) return `${s*1000} ms/div`;
    return `${s*1e6} µs/div`;
  }

  function attachKnobDrag(el, list, getIdx, setIdx, labelEl, fmt, needleEl){
    let dragging = false;

    function applyIndex(i){
      const idx = Math.max(0, Math.min(list.length-1, i));
      if (idx !== getIdx()){
        setIdx(idx);
        labelEl.textContent = fmt(list[idx]);
        setNeedle(needleEl, list, idx);
        draw();
      }
    }
    function onDown(e){
      dragging = true; e.preventDefault(); onMove(e);
    }
    function onMove(e){
      if (!dragging) return;
      e.preventDefault();
      const ang = angleFromEvent(e, el);       // 0..330
      const idx = idxFromAngle(ang, list);     // snap au cran le + proche
      applyIndex(idx);
    }
    function onUp(){ dragging = false; }

    // Souris
    el.addEventListener('mousedown', onDown);
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
    // Tactile
    el.addEventListener('touchstart', onDown, {passive:false});
    window.addEventListener('touchmove', onMove, {passive:false});
    window.addEventListener('touchend', onUp);

    // init visuelle
    labelEl.textContent = fmt(list[getIdx()]);
    setNeedle(needleEl, list, getIdx());
  }

  attachKnobDrag(
    document.getElementById('knobV'), VDIV_STEPS,
    ()=>vIndex, (i)=>{ vIndex=i; },
    vLabel, fmtV, vNeedle
  );
  attachKnobDrag(
    document.getElementById('knobT'), TDIV_STEPS,
    ()=>tIndex, (i)=>{ tIndex=i; },
    tLabel, fmtT, tNeedle
  );

  // ---- Période <-> Fréquence (bidirectionnel)
  let syncingFP = false;
  function setFreqFromPer(){
    if (syncingFP) return;
    const P = parseFloat(ui.per.value);
    if (!isFinite(P) || P <= 0) return;
    syncingFP = true;
    ui.freq.value = (1 / P).toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
    syncingFP = false;
    draw();
  }
  function setPerFromFreq(){
    if (syncingFP) return;
    const f = parseFloat(ui.freq.value);
    if (!isFinite(f) || f <= 0) return;
    syncingFP = true;
    ui.per.value = (1 / f).toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
    syncingFP = false;
    draw();
  }
  setPerFromFreq();
  ui.freq.addEventListener('input',  setPerFromFreq);
  ui.freq.addEventListener('change', setPerFromFreq);
  ui.per .addEventListener('input',  setFreqFromPer);
  ui.per .addEventListener('change', setFreqFromPer);

  // ---- Pan vertical à la molette + clic droit = recentrer
  cvs.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const deltaDiv = (e.deltaY > 0 ? 0.2 : -0.2);
    yCenterDiv = Math.max(0, Math.min(DIV_Y, yCenterDiv + deltaDiv));
    draw();
  }, {passive:false});
  cvs.addEventListener('contextmenu', (e)=>{ e.preventDefault(); yCenterDiv = DIV_Y/2; draw(); });

  // ---- Export PNG (écran de l’oscillo)
  function exportScreenPNG(){
    const bg = document.getElementById('bg');
    const trace = document.getElementById('trace');

    const css = getComputedStyle(document.documentElement);
    const leftPct = parseFloat(css.getPropertyValue('--screen-left'));
    const topPct  = parseFloat(css.getPropertyValue('--screen-top'));
    const wPct    = parseFloat(css.getPropertyValue('--screen-width'));
    const hPct    = parseFloat(css.getPropertyValue('--screen-height'));

    const nW = bg.naturalWidth, nH = bg.naturalHeight;

    const sx = Math.round(nW * leftPct / 100);
    const sy = Math.round(nH * topPct  / 100);
    const sW = Math.round(nW * wPct    / 100);
    const sH = Math.round(nH * hPct    / 100);

    const off = document.createElement('canvas');
    off.width = sW; off.height = sH;
    const octx = off.getContext('2d');

    // Zone de fond (grille)
    octx.drawImage(bg, sx, sy, sW, sH, 0, 0, sW, sH);
    // Trace (scalée à la même taille)
    octx.drawImage(trace, 0, 0, trace.width, trace.height, 0, 0, sW, sH);

    const a = document.createElement('a');
    a.href = off.toDataURL('image/png');
    a.download = `oscilloscope_ecran.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
  ui.exportPng.addEventListener('click', exportScreenPNG);

  // ---- INIT robuste : attendre l'image + redraw sur resize ----
  const bg = document.getElementById('bg');
  const ro = new ResizeObserver(() => draw());
  function init(){
    ro.observe(document.getElementById('scope'));
    ro.observe(cvs);
    requestAnimationFrame(() => { draw(); setTimeout(draw, 80); });
  }
  if (bg.complete) init(); else bg.addEventListener('load', init, {once:true});

  // Redessiner si fenêtre redimensionnée + si paramètres changent
  window.addEventListener('resize', draw);
  ['change','input'].forEach(ev => {
    [ui.wave, ui.freq, ui.per, ui.amp, ui.offset].forEach(el => el && el.addEventListener(ev, draw));
  });
</script>
</body>
</html>
